把起始格添加到 "正向开启列表" ，把终点添加到 "反向开启列表" 
将起点设置为正向开启列表的F值最低的格子cur_grid1，将终点设置为反向开启列表的F最低的格子cur_grid2
do 
{ 
       //正向A*
        以将cur_grid1设为当前格. 
        把它切换到正向关闭列表. 
        对当前格相邻的8格中的每一个 
        if (它不可通过 || 已经在 "正向关闭列表" 中) 
        { 
                什么也不做. 
        } 
        if (它不在正向开启列表中) 
        { 
                把它添加进 "正向开启列表", 把当前格作为这一格的父节点, 并根据cur_grid2，计算这一格的 FGH 
        }
        if (它已经在正向开启列表中) 
        { 
                if (用 G 值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                { 
                        把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
                } 
        }
.       if(cur_grid2已经在 "正向开启列表" ) 找到路径; break;
        将cur_grid1重置为正向开启列表的F值最小的栅格

       //反向A*
.       以将cur_grid2设为当前格. 
        把它切换到反向关闭列表. 
        对当前格相邻的8格中的每一个 
        if (它不可通过 || 已经在 "反向关闭列表" 中) 
        { 
                什么也不做. 
        } 
        if (它不在反向开启列表中) 
        { 
                把它添加进 "反向开启列表", 把当前格作为这一格的父节点, 并根据cur_grid1，计算这一格的 FGH 
        }
        if (它已经在反向开启列表中) 
        { 
                if (用 G 值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                { 
                        把这一格的父节点改成当前格, 并且重新计算这一格的 G F 值. 
                } 
        }
.       if(cur_grid1已经在 "反向开启列表" ) 找到路径; break;
        将cur_grid2重置为反向开启列表的F值最小的栅格

} while( 正向开启列表不为空 && 反向开启列表不为空) 
如果正向开启列表或反向开启列表已经空了, 说明路径不存在.
 
最后从cur_grid1沿父节点回溯到起点，从cur_grid2沿父节点回溯到终点，合并两条路径得到最终路径.